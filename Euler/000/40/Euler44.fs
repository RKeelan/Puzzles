module Euler44

(*
Pentagonal numbers are generated by the formula, Pn=n(3n−1)/2. The first ten pentagonal numbers are:

1, 5, 12, 22, 35, 51, 70, 92, 117, 145, ...

It can be seen that P4 + P7 = 22 + 70 = 92 = P8. However, their difference, 70 − 22 = 48, is not
pentagonal.

Find the pair of pentagonal numbers, Pj and Pk, for which their sum and difference are pentagonal
and D = |Pk − Pj| is minimised; what is the value of D?
https://projecteuler.net/problem=44
*)

(*
- The pentagon numbers get progressively further apart, so D = |Pk − Pj| is lowest when Pk and Pj
are closest together, and as low as possible
- I think I need to use something like the A* algorithm to decide if I'm better off (e.g.,) checking
- Pi+1 / Pj+1 or Pi / Pj+2
- Put another way, P1 and P2 don't have a pentagonal difference, but what should I check next:
    - P2 and P3
    - P1 and P3
- More generally, if Pk/Pj fails, I need to decide whether to increment k or j for my next attempt
    - I'd decide that by checking which increment can give me a lower result
*)

open System
open FSharpx.Collections
open Humanizer
open Numbers
open Search

type PentagonPair(jIn:int, kIn:int) =
    member val j = jIn with get
    member val k = kIn with get
    member val pj = pentagonNumber jIn
    member val pk = pentagonNumber kIn
    override this.Equals(otherObj:obj) = 
        match otherObj with
        | :? PentagonPair as other -> (this.j = other.j) && (this.k = other.k)
        | _ -> false
    override this.GetHashCode() =
        let mutable hash = 17
        hash <- hash * 23 + this.j.GetHashCode()
        hash <- hash * 23 + this.k.GetHashCode()
        hash
    override this.ToString() = $"({this.j:N0}, {this.k:N0})\tpj:{this.pj:N0}\tpk:{this.pk:N0}"

// RK 29-Dec-2021: So it turns out I didn't need any of this stuff, and in fact this "search" was
// the opposite of efficient--it prevented me from finding any pairs at all
let isGoal (pair:PentagonPair) =
    let sum = pair.pj + pair.pk
    let diff = abs(pair.pj - pair.pk)
    (isPentagonNumber sum) && (isPentagonNumber diff)
    //(pair.j = 9 && pair.k = 10) || (pair.j = 10 && pair.k = 9)
    
// Ok, this is definitely resulting in the same nodes being added more than once
let getNeighbours (pair:PentagonPair) =
    seq {
        let jParent = if pair.j+1 = pair.k then PentagonPair(pair.j+2, pair.k)
                      else PentagonPair(pair.j+1, pair.k)
        //printfn $"\tYielding {jParent}"
        yield (abs(jParent.pj - jParent.pk), jParent)
        let kParent = if pair.k+1 = pair.j then PentagonPair(pair.j, pair.k+2)
                      else PentagonPair(pair.j, pair.k+1)
        //printfn $"\tYielding {kParent}"
        yield (abs(kParent.pj - kParent.pk), kParent)
    }

let limit = 1000000
let dumbSearch =
    seq {
    for j in 2..1000000 do
        for k in 1..j-1 do
            let pair = PentagonPair(j,k)
            if isGoal pair then yield pair
    }

//[<EntryPoint>]
let main argv =
    let stopWatch = System.Diagnostics.Stopwatch.StartNew()
    
    let pair = dumbSearch |> Seq.take 1 |> Seq.head
    printfn $"Pj is {pair.pj}, the {pair.j.Ordinalize()} pentagon number"
    printfn $"Pk is {pair.pk}, the {pair.k.Ordinalize()} pentagon number"
    printfn $"The difference is {abs (pair.pj - pair.pk)}\n"
    
    stopWatch.Stop()
    printfn $"Execution time: {stopWatch.Elapsed.TotalMilliseconds:N0} ms." 
    0